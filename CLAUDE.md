# libsignal - Claude Code Configuration

## Important Rules

**ALWAYS use Makefile commands.** Never call scripts directly via `fvm dart run scripts/...`. The Makefile is the single entry point for all operations.

```bash
# Correct - pass arguments via ARGS variable
make build ARGS="macos"
make build ARGS="macos --arch arm64"
make test
make analyze ARGS="--fatal-infos"

# Wrong - never do this
fvm dart run scripts/build.dart macos
make build macos --arch arm64  # make interprets --arch as its own flag!
```

## Quick Reference

| Task | Command |
|------|---------|
| Initial setup | `make setup` |
| Show all commands | `make help` |
| Build native library | `make build ARGS="<platform>"` |
| Run tests | `make test` |
| Run analysis | `make analyze` |
| Strict analysis | `make analyze ARGS="--fatal-infos"` |
| Format code | `make format` |
| Regenerate FFI bindings | `make regen` |
| Check for updates | `make check` |
| Get dependencies | `make get` |
| Show libsignal version | `make version` |

## Project Overview

Dart FFI bindings for libsignal - Signal Protocol implementation for end-to-end encryption.

### Key Features
- Signal Protocol (Double Ratchet, X3DH)
- Sealed Sender (anonymous messaging)
- Group Messaging (SenderKey)
- Pre-built native libraries for all platforms
- Automated security updates via GitHub Actions

### Upstream Repository
- **libsignal**: https://github.com/signalapp/libsignal

## Project Structure

```
libsignal/
├── lib/                            # Dart library code
│   └── src/
│       ├── bindings/
│       │   └── libsignal_bindings.dart  # Auto-generated FFI bindings
│       ├── keys.dart               # Key types (PrivateKey, PublicKey, etc.)
│       ├── protocol.dart           # Signal Protocol (sessions, encryption)
│       ├── stores.dart             # Store abstractions
│       ├── sealed_sender.dart      # Sealed sender
│       └── groups.dart             # Group messaging
├── bin/                            # Pre-built server/CLI libraries
│   ├── linux/libsignal_ffi.so
│   ├── macos/libsignal_ffi.dylib
│   └── windows/signal_ffi.dll
├── android/src/main/jniLibs/       # Android libraries
├── ios/Libraries/                  # iOS libraries
├── macos/Libraries/                # macOS Flutter library
├── headers/                        # C headers (generated by cbindgen)
│   └── signal_ffi.h
├── scripts/                        # Build scripts (use via Makefile!)
├── test/                           # Tests
├── Makefile                        # Entry point for all commands
├── LIBSIGNAL_VERSION               # Current libsignal version
└── .github/workflows/              # CI/CD workflows
```

## Build System

This project uses **Rust/Cargo** to build libsignal (unlike liboqs which uses CMake).

### Rust Targets

| Platform | Rust Target |
|----------|-------------|
| Linux x86_64 | `x86_64-unknown-linux-gnu` |
| Linux arm64 | `aarch64-unknown-linux-gnu` |
| macOS arm64 | `aarch64-apple-darwin` |
| macOS x86_64 | `x86_64-apple-darwin` |
| iOS device | `aarch64-apple-ios` |
| iOS simulator arm64 | `aarch64-apple-ios-sim` |
| iOS simulator x86_64 | `x86_64-apple-ios` |
| Android arm64 | `aarch64-linux-android` |
| Android arm | `armv7-linux-androideabi` |
| Android x86_64 | `x86_64-linux-android` |
| Windows | `x86_64-pc-windows-msvc` |

### Build Requirements

- **Rust toolchain** (rustup, cargo)
- **cbindgen** (for C header generation)
- **Android NDK** (for Android builds)
- **Xcode** (for iOS/macOS builds)

## Supported Platforms

| Platform | Architecture | Library | Location |
|----------|--------------|---------|----------|
| Linux | x86_64, arm64 | `libsignal_ffi.so` | `bin/linux/` |
| macOS | Universal | `libsignal_ffi.dylib` | `bin/macos/` |
| Windows | x86_64 | `signal_ffi.dll` | `bin/windows/` |
| iOS | device, simulator | `libsignal_ffi.dylib` | `ios/Libraries/` |
| Android | arm64-v8a, armeabi-v7a, x86_64 | `libsignal_ffi.so` | `android/src/main/jniLibs/` |

## FVM (Flutter Version Management)

This project uses FVM for consistent Flutter/Dart versions.

**Version:** Flutter 3.38.4 (Dart SDK 3.10.0)

FVM is automatically installed by `make setup`.

## FFI Workaround: Fixed-Size Array Parameters

### The Problem

The libsignal C header declares some functions with fixed-size array output parameters:
```c
SignalFfiError signal_sender_key_message_get_distribution_id(
    uint8_t (*out)[16],  // Pointer to array of 16 bytes
    SignalConstPointerSenderKeyMessage msg
);
```

However, `ffigen` incorrectly generates `Pointer<Pointer<Uint8>>` for the type `uint8_t (*)[N]`. This causes:
1. Incorrect memory allocation when using `calloc<Pointer<Uint8>>()`
2. SEGFAULT when libsignal writes 16 bytes to a pointer-sized allocation

### The Workaround

Use a Dart `Struct` with `Array<Uint8>` to allocate the exact number of bytes:

```dart
final class _Uuid16 extends Struct {
  @Array.multi([16])
  external Array<Uint8> bytes;
}

Uint8List get distributionId {
  final outPtr = calloc<_Uuid16>();  // Allocates exactly 16 bytes
  try {
    // Cast when calling the FFI function
    final error = signal_..._get_distribution_id(
      outPtr.cast<Pointer<Uint8>>(),
      ...
    );
    // Copy bytes from struct
    final result = Uint8List(16);
    for (var i = 0; i < 16; i++) {
      result[i] = outPtr.ref.bytes[i];
    }
    return result;
  } finally {
    calloc.free(outPtr);
  }
}
```

### Why This Is Safe

- The allocated size (16 bytes) exactly matches what libsignal expects
- We copy data before freeing memory
- Tests verify correct values are returned
- The workaround survives `make regen` because it's in wrapper code, not in generated bindings

### Affected Functions

Functions with `uint8_t (*out)[16]` parameter that need this workaround:
- `signal_sender_key_distribution_message_get_distribution_id` ✅ Fixed
- `signal_sender_key_message_get_distribution_id` ✅ Fixed
- `signal_sender_key_distribution_message_create` ✅ Fixed (input parameter)
- `signal_group_encrypt_message` ✅ Fixed (input parameter)
- `signal_error_get_uuid` - Not implemented (error handling)

Functions with other fixed-size arrays (not currently used):
- Various zkgroup functions with `uint8_t (*)[32]`, `uint8_t (*)[64]`, etc.

## FFI Known Issue: 16-byte Struct Passed by Value (ARM64)

### The Problem

The native `signal_sender_certificate_validate` function takes a `SignalBorrowedSliceOfConstPointerPublicKey` struct (16 bytes: pointer + size_t) **by value**. On ARM64, there's a Dart FFI ABI issue where the data is not passed correctly to the native library.

### Solution

`SenderCertificate.validate()` is implemented in pure Dart using manual signature verification instead of the FFI call. This provides identical functionality and works on all platforms.

The Dart implementation:
1. Verifies server certificate signature against trust root
2. Verifies sender certificate signature against server's key
3. Checks certificate expiration

When the Dart FFI issue is resolved, the implementation can be switched to use the native `signal_sender_certificate_validate` function without breaking changes.

### Related Resources

- [Dart FFI structs by value (GitHub #36730)](https://github.com/dart-lang/sdk/issues/36730)
- [Implementing structs by value in Dart FFI (Medium)](https://medium.com/dartlang/implementing-structs-by-value-in-dart-ffi-1cb1829d11a9)

## Unimplemented Functionality

Some libsignal features are not yet implemented in this library:

### zkgroup (Zero-Knowledge Groups)
- Profile keys, credentials, group calls
- Server-side verification
- Not needed for basic Signal Protocol messaging

### Session Establishment (signal_process_prekey_bundle)
- Requires implementing FFI callbacks for SessionStore and IdentityKeyStore
- Complex task involving async callbacks from C to Dart
- Currently, session initialization is not fully implemented

### SVR (Secure Value Recovery)
- Server-side functionality for PIN-based backups
- Not typically needed in client applications
